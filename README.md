# goit-algo-hw-04
Basic Algorithms


# Висновки щодо ефективності алгоритмів сортування

У ході виконання домашнього завдання було проведено порівняльний аналіз трьох алгоритмів сортування:
* **Insertion Sort** (сортування вставками);
* **Merge Sort** (сортування злиттям);
* **Timsort** (вбудований алгоритм Python).

Емпіричні дані, отримані за допомогою модуля `timeit`, дозволяють зробити наступні висновки:

## 1. Ефективність Insertion Sort (Сортування вставками)

* **Результат:** Цей алгоритм показав найгірший час виконання на великих наборах даних.
* **Теоретичне обґрунтування:** Алгоритм має квадратичну часову складність $O(n^2)$. Це означає, що при збільшенні кількості елементів у 10 разів, час виконання зростає приблизно у 100 разів.
* **Висновок:** Insertion Sort ефективний лише для дуже малих масивів (зазвичай до 20-50 елементів) або частково відсортованих даних. Використання його для великих масивів (наприклад, 2000+ елементів) є недоцільним через критичне падіння продуктивності.

## 2. Ефективність Merge Sort (Сортування злиттям)

* **Результат:** Алгоритм працює значно швидше за сортування вставками на великих обсягах даних.
* **Теоретичне обґрунтування:** Merge Sort має складність $O(n \log n)$. Він використовує підхід "розділяй і володарюй", розбиваючи масив навпіл, що дозволяє утримувати час виконання в розумних межах навіть при зростанні кількості даних.
* **Висновок:** Це надійний алгоритм для сортування великих масивів, проте його реалізація на "чистому" Python програє вбудованим функціям через накладні витрати інтерпретатора.

## 3. Ефективність Timsort (Вбудований алгоритм sorted/sort)

* **Результат:** Timsort виявився найшвидшим у всіх тестах, випереджаючи ручні реалізації на порядки.
* **Теоретичне обґрунтування:**
    * **Гібридна природа:** Timsort поєднує ефективність Insertion Sort для малих підмасивів та потужність Merge Sort для об'єднання відсортованих частин.
    * **Оптимізація CPython:** Вбудовані функції Python (`sorted`, `list.sort`) написані мовою C. Це дозволяє виконувати операції безпосередньо в машинному коді, оминаючи повільний цикл інтерпретації Python.
* **Висновок:** Timsort є стандартом індустрії завдяки своїй адаптивності до реальних даних (які часто вже мають часткову впорядкованість) та низькорівневій оптимізації.

---

### Загальний підсумок

Експеримент підтвердив, що для практичних задач у Python **завжди слід використовувати вбудовані функції сортування**. Вони забезпечують найкращу швидкодію завдяки поєднанню ефективного алгоритму (Timsort). Власні реалізації алгоритмів корисні виключно для навчальних цілей та розуміння принципів роботи структур даних.